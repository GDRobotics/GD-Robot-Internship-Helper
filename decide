#region Assembly Accord.MachineLearning, Version=3.8.0.0, Culture=neutral, PublicKeyToken=fa1a88e29555ccf7
// C:\Users\Okan\documents\visual studio 2015\Projects\anomalyyyyyyy\packages\Accord.MachineLearning.3.8.0\lib\net45\Accord.MachineLearning.dll
#endregion

using System;
using Accord.Statistics.Kernels;
using Accord.Statistics.Models.Regression;
using Accord.Statistics.Models.Regression.Linear;

namespace Accord.MachineLearning.VectorMachines
{
    //
    // Summary:
    //     Sparse Kernel Support Vector Machine (kSVM)
    //
    // Remarks:
    //     The original optimal hyperplane algorithm (SVM) proposed by Vladimir Vapnik in
    //     1963 was a linear classifier. However, in 1992, Bernhard Boser, Isabelle Guyon
    //     and Vapnik suggested a way to create non-linear classifiers by applying the kernel
    //     trick (originally proposed by Aizerman et al.) to maximum-margin hyperplanes.
    //     The resulting algorithm is formally similar, except that every dot product is
    //     replaced by a non-linear kernel function.
    //     This allows the algorithm to fit the maximum-margin hyperplane in a transformed
    //     feature space. The transformation may be non-linear and the transformed space
    //     high dimensional; thus though the classifier is a hyperplane in the high-dimensional
    //     feature space, it may be non-linear in the original input space.
    //     The machines are also able to learn sequence classification problems in which
    //     the input vectors can have arbitrary length. For an example on how to do that,
    //     please see the documentation page for the Accord.Statistics.Kernels.DynamicTimeWarping.
    //     References: http://en.wikipedia.org/wiki/Support_vector_machine http://www.kernel-machines.org/
    public class SupportVectorMachine<TKernel, TInput> : BinaryLikelihoodClassifierBase<TInput>, ISupportVectorMachine<TInput>, IBinaryLikelihoodClassifier<TInput>, IBinaryScoreClassifier<TInput>, IBinaryClassifier<TInput>, IMulticlassClassifier<TInput>, IMultilabelClassifier<TInput>, IMultilabelClassifier<TInput, int[]>, IClassifier<TInput, int[]>, IClassifier, ITransform<TInput, int[]>, ICovariantTransform<TInput, int[]>, ITransform, IMultilabelClassifier<TInput, bool[]>, IClassifier<TInput, bool[]>, ITransform<TInput, bool[]>, ICovariantTransform<TInput, bool[]>, IMultilabelClassifier<TInput, double[]>, IClassifier<TInput, double[]>, ITransform<TInput, double[]>, ICovariantTransform<TInput, double[]>, IMulticlassClassifier<TInput, int>, IClassifier<TInput, int>, ITransform<TInput, int>, ICovariantTransform<TInput, int>, IMulticlassClassifier<TInput, double>, IClassifier<TInput, double>, ITransform<TInput, double>, ICovariantTransform<TInput, double>, IClassifier<TInput, bool>, ITransform<TInput, bool>, ICovariantTransform<TInput, bool>, IMulticlassOutScoreClassifier<TInput, bool>, IMulticlassScoreClassifierBase<TInput, bool>, IMultilabelOutScoreClassifier<TInput, bool>, IMultilabelScoreClassifierBase<TInput, bool>, IMulticlassScoreClassifier<TInput>, IMulticlassScoreClassifier<TInput, int>, IMulticlassOutScoreClassifier<TInput, int>, IMulticlassScoreClassifierBase<TInput, int>, IMultilabelOutScoreClassifier<TInput, int>, IMultilabelScoreClassifierBase<TInput, int>, IMulticlassRefScoreClassifier<TInput, int[]>, IMultilabelRefScoreClassifier<TInput, int[]>, IMultilabelScoreClassifierBase<TInput, int[]>, IMulticlassScoreClassifier<TInput, double>, IMulticlassOutScoreClassifier<TInput, double>, IMulticlassScoreClassifierBase<TInput, double>, IMultilabelOutScoreClassifier<TInput, double>, IMultilabelScoreClassifierBase<TInput, double>, IMulticlassRefScoreClassifier<TInput, double[]>, IMultilabelRefScoreClassifier<TInput, double[]>, IMultilabelScoreClassifierBase<TInput, double[]>, IMulticlassRefScoreClassifier<TInput, bool[]>, IMultilabelRefScoreClassifier<TInput, bool[]>, IMultilabelScoreClassifierBase<TInput, bool[]>, IMultilabelScoreClassifier<TInput>, IMultilabelScoreClassifier<TInput, int>, IMultilabelScoreClassifier<TInput, double>, IMulticlassOutLikelihoodClassifier<TInput, bool>, IMultilabelOutLikelihoodClassifier<TInput, bool>, IMultilabelLikelihoodClassifierBase<TInput, bool>, IMulticlassLikelihoodClassifierBase<TInput, bool>, IMulticlassLikelihoodClassifier<TInput>, IMulticlassLikelihoodClassifier<TInput, int>, IMulticlassOutLikelihoodClassifier<TInput, int>, IMultilabelOutLikelihoodClassifier<TInput, int>, IMultilabelLikelihoodClassifierBase<TInput, int>, IMulticlassLikelihoodClassifierBase<TInput, int>, IMulticlassRefLikelihoodClassifier<TInput, int[]>, IMultilabelRefLikelihoodClassifier<TInput, int[]>, IMultilabelLikelihoodClassifierBase<TInput, int[]>, IMulticlassLikelihoodClassifier<TInput, double>, IMulticlassOutLikelihoodClassifier<TInput, double>, IMultilabelOutLikelihoodClassifier<TInput, double>, IMultilabelLikelihoodClassifierBase<TInput, double>, IMulticlassLikelihoodClassifierBase<TInput, double>, IMulticlassRefLikelihoodClassifier<TInput, double[]>, IMultilabelRefLikelihoodClassifier<TInput, double[]>, IMultilabelLikelihoodClassifierBase<TInput, double[]>, IMulticlassRefLikelihoodClassifier<TInput, bool[]>, IMultilabelRefLikelihoodClassifier<TInput, bool[]>, IMultilabelLikelihoodClassifierBase<TInput, bool[]>, IMultilabelLikelihoodClassifier<TInput>, IMultilabelLikelihoodClassifier<TInput, int>, IMultilabelLikelihoodClassifier<TInput, double>, ICloneable where TKernel : IKernel<TInput>
    {
        //
        // Summary:
        //     Initializes a new instance of the Accord.MachineLearning.VectorMachines.SupportVectorMachine`2
        //     class.
        //
        // Parameters:
        //   inputs:
        //     The length of the input vectors expected by the machine.
        //
        //   kernel:
        //     The kernel function to be used.
        public SupportVectorMachine(int inputs, TKernel kernel);

        //
        // Summary:
        //     Gets the number of inputs accepted by this machine.
        //
        // Remarks:
        //     If the number of inputs is zero, this means the machine accepts a indefinite
        //     number of inputs. This is often the case for kernel vector machines using a sequence
        //     kernel.
        [Obsolete("Please use NumberOfInputs instead.")]
        public int Inputs { get; }
        //
        // Summary:
        //     Obsolete.
        [Obsolete("A machine in compact form is simply a machine with a single support vector.")]
        public bool IsCompact { get; }
        //
        // Summary:
        //     Gets whether this machine has been calibrated to produce probabilistic outputs
        //     (through the Probability(TInput) method).
        public bool IsProbabilistic { get; set; }
        //
        // Summary:
        //     Gets or sets the kernel used by this machine.
        public TKernel Kernel { get; set; }
        //
        // Summary:
        //     Gets or sets the collection of support vectors used by this machine.
        public TInput[] SupportVectors { get; set; }
        //
        // Summary:
        //     Gets or sets the threshold (bias) term for this machine.
        public double Threshold { get; set; }
        //
        // Summary:
        //     Gets or sets the collection of weights used by this machine.
        public double[] Weights { get; set; }

        //
        // Summary:
        //     Creates a new object that is a copy of the current instance.
        //
        // Returns:
        //     A new object that is a copy of this instance.
        public virtual object Clone();
        //
        // Summary:
        //     If this machine has a linear kernel, compresses all support vectors into a single
        //     parameter vector.
        public virtual void Compress();
        //
        // Summary:
        //     Computes the given input to produce the corresponding output.
        //
        // Parameters:
        //   inputs:
        //     An input vector.
        //
        // Returns:
        //     The output for the given input. In a typical classification problem, the sign
        //     of this value should be considered as the class label.
        //
        // Remarks:
        //     For a binary decision problem, the decision for the negative or positive class
        //     is typically computed by taking the sign of the machine's output.
        [Obsolete("Please use the Decide or Transform methods instead.")]
        public double Compute(TInput inputs);
        //
        // Summary:
        //     Computes the given input to produce the corresponding output.
        //
        // Parameters:
        //   inputs:
        //     An input vector.
        //
        //   output:
        //     The output of the machine. If this is a Accord.MachineLearning.VectorMachines.SupportVectorMachine`2.IsProbabilistic
        //     machine, the output is the probability of the positive class. If this is a standard
        //     machine, the output is the distance to the decision hyperplane in feature space.
        //
        // Returns:
        //     The decision label for the given input.
        //
        // Remarks:
        //     For a binary decision problem, the decision for the negative or positive class
        //     is typically computed by taking the sign of the machine's output.
        [Obsolete("Please use the Decide or Transform methods instead.")]
        public virtual int Compute(TInput inputs, out double output);
        //
        // Summary:
        //     Computes a class-label decision for a given input.
        //
        // Parameters:
        //   input:
        //     The input vector that should be classified into one of the Accord.MachineLearning.ITransform.NumberOfOutputs
        //     possible classes.
        //
        // Returns:
        //     A class-label that best described input according to this classifier.
        public override bool Decide(TInput input);
        //
        // Summary:
        //     Predicts a class label vector for the given input vectors, returning the log-likelihood
        //     that the input vector belongs to its predicted class.
        //
        // Parameters:
        //   input:
        //     The input vector.
        //
        //   result:
        //     An array where the log-likelihoods will be stored, avoiding unnecessary memory
        //     allocations.
        //
        // Returns:
        //     System.Double[].
        public override double[] LogLikelihood(TInput[] input, double[] result);
        //
        // Summary:
        //     Computes a numerical score measuring the association between the given input
        //     vector and each class.
        //
        // Parameters:
        //   input:
        //     The input vector.
        //
        //   result:
        //     An array where the result will be stored, avoiding unnecessary memory allocations.
        //
        // Returns:
        //     System.Double[].
        public override double[] Score(TInput[] input, double[] result);
        //
        // Summary:
        //     Converts a Accord.Statistics.Kernels.Linear-kernel machine into an array of linear
        //     coefficients. The first position in the array is the Accord.MachineLearning.VectorMachines.SupportVectorMachine`2.Threshold
        //     value.
        //
        // Returns:
        //     An array of linear coefficients representing this machine.
        public virtual double[] ToWeights();

        //
        // Summary:
        //     Performs an explicit conversion from Accord.MachineLearning.VectorMachines.SupportVectorMachine
        //     to Accord.Statistics.Models.Regression.Linear.MultipleLinearRegression.
        //
        // Parameters:
        //   svm:
        //     The Accord.MachineLearning.VectorMachines.SupportVectorMachine to be converted.
        //
        // Returns:
        //     The result of the conversion.
        public static explicit operator MultipleLinearRegression(SupportVectorMachine<TKernel, TInput> svm);
        //
        // Summary:
        //     Performs an explicit conversion from Accord.MachineLearning.VectorMachines.SupportVectorMachine
        //     to Accord.Statistics.Models.Regression.LogisticRegression.
        //
        // Parameters:
        //   svm:
        //     The Accord.MachineLearning.VectorMachines.SupportVectorMachine to be converted.
        //
        // Returns:
        //     The result of the conversion.
        public static explicit operator LogisticRegression(SupportVectorMachine<TKernel, TInput> svm);
    }
}
